#summary Lexicon of terms and abbreviations used in the plop code and docs

*Note:* I apply some mathematical terminology rather loosely to describe functions with side-effect. For example, I will describe a function f as idempotent if calling it N times has the same effect as calling it once (rather than the "strict" interpretation meaning `f(f(x))=x`). 

_This is very incomplete..._ 

  * *plop* Probabilistic learning of programs, the name of a software system being implemented in Common Lisp. The greatest thing since sliced bread.
  * *moses* Meta-optimizing semantic evolutionary search, the name of an algorithm for probabilistic program induction, first described in the dissertation [http://metacog.org/main.pdf Competent Program Evolution]. The greatest thing since the idea of slicing bread.
  * *expression* A well-typed program tree that is either an atom or a function application. A function application is a proper list (of unshared conses) whose cdr is a list of expressions. An expression may be in `s` format, in which case the cars of function applications must be a function name symbol (e.g. `(f arg1 ... argN)`), or in `p` format, where the cars of function applications are conses whose cars are function name symbols and whose cdrs are markup lists (e.g. `((f markup) arg1 ... argN)`).
  * *markup* A plist containing properties of interest (e.g. reduction status) of a function application in `p` format.
  * *reduct* A system for simplifying and otherwise normalizing expressions (e.g. `(and x x y)` gets _reduced_ to `(and x y)`).
  * *exemplar* A monomorphically typed `p` expression of interest.
  * *setting* A CL function taking no arguments, with a corresponding exemplar. Calling a setting may modify its corresponding exemplar in some way as a side-effect, such that it remains an expression and its type remains the same. Settings must be idempotent.
  * *default-setting* A default setting is a setting that, applied when the exemplar is unmodified (i.e. has not had any other settings called on it), has no effect.
  * *knob* An independent degree of freedom represented as a vector of settings. The first setting in the vector is the default, and the length of the vector must be at least two. The settings must all have the same exemplar, and must be mutually exclusive, meaning that calling one setting in a knob followed by a second setting will have the same effect as if only the second setting was called. The length of the vector is the knob's arity.
  * *rep* Representation, a set of knobs (implemented as a vector of knobs), all acting on the same exemplar. All of the knobs in a representation must be independent, meaning that any sequence of calls to settings in the knobs is valid. A sequence of settings in a representation which all correspond to differing knobs is commutative - calling the settings in any order must leave the exemplar in the same state.
  * *addr* Address, for a particular representation, a description of some expression that can be reached by calling a sequence of knobs. Addresses correspond to points in the discrete space whose dimensions are the representation's knobs. For example, a representation consisting of N binary knobs (knobs with arity two) will have 2^N corresponding addresses. Accordingly, every address maps to exactly on expression, and the mapping from addresses for a representation to expressions is injective. Addresses are implemented as lists of `(knob index, setting index)` pairs (conses), sorted in ascending order by knob index. Note that each knob index can appear at most once in an address.
  * *cardinality* The cardinality of a representation is the number of corresponding addresses.
  * *pnode* An expression mapped to from at least one address, and possibly mapped to by multiple addresses in multiple representations. Implemented as a struct that keeps track of all of the aforementioned addresses, along with corresponding information regarding the expression's usefulness in the context of a particular program induction problem.
